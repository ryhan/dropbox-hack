#!/usr/bin/env python
#
# Sample dropblox_ai exectuable.
#

import json
import sys
import time
import copy

class InvalidMoveError(ValueError):
  pass

# A class representing an (i, j) position on a board.
class Point(object):
  def __init__(self, i=0, j=0):
    self.i = i
    self.j = j

# A class representing a Block object.
class Block(object):
  def __init__(self, center, offsets):
    # The block's center and offsets should not be mutated.
    self.center = Point(center['i'], center['j'])
    self.offsets = tuple(Point(offset['i'], offset['j']) for offset in offsets)
    # To move the block, we can change the Point "translation" or increment
    # the value "rotation".
    self.translation = Point()
    self.rotation = 0

  # A generator that returns a list of squares currently occupied by this
  # block. Takes translations and rotations into account.
  def squares(self):
    if self.rotation % 2:
      for offset in self.offsets:
        yield Point(
          self.center.i + self.translation.i + (2 - self.rotation)*offset.j,
          self.center.j + self.translation.j - (2 - self.rotation)*offset.i,
        )
    else:
      for offset in self.offsets:
        yield Point(
          self.center.i + self.translation.i + (1 - self.rotation)*offset.i,
          self.center.j + self.translation.j + (1 - self.rotation)*offset.j,
        )

  def left(self):
    self.translation.j -= 1

  def right(self):
    self.translation.j += 1

  def up(self):
    self.translation.i -= 1

  def down(self):
    self.translation.i += 1

  def rotate(self):
    self.rotation += 1

  def unrotate(self):
    self.rotation -= 1

  # The checked_* methods below perform an operation on the block
  # only if it's a legal move on the passed in board.  They
  # return True if the move succeeded.
  def checked_left(self, board):
    self.left()
    if board.check(self):
        return True
    self.right()
    return False

  def checked_right(self, board):
    self.right()
    if board.check(self):
        return True
    self.left()
    return False

  def checked_down(self, board):
    self.down()
    if board.check(self):
        return True
    self.up()
    return False

  def checked_up(self, board):
    self.up()
    if board.check(self):
        return True
    self.down()
    return False

  def checked_rotate(self, board):
    self.rotate()
    if board.check(self):
        return True
    self.unrotate()
    return False

  def do_command(self, command):
    assert(command in ('left', 'right', 'up', 'down', 'rotate')), \
        'Unexpected command %s' % (command,)
    getattr(self, command)()

  def do_commands(self, commands):
    for command in commands:
      self.do_command(command)

  def reset_position(self):
    (self.translation.i, self.translation.j) = (0, 0)
    self.rotation = 0

# A class representing a board state. Stores the current block and the
# preview list and handles commands.
class Board(object):
  rows = 33
  cols = 12
  def __init__(self, bitmap, block, preview):
    self.bitmap = bitmap
    self.block = block
    self.preview = preview
    self.rows = 33 
    self.cols = 12 

  def __repr__(self):
    return str(self)

  def __str__(self):
    return '\n'.join(' '.join('X' if elt else '.' for elt in row) for row in self.bitmap)

  @staticmethod
  def construct_from_json(state_json):
    state = json.loads(state_json)
    block = Block(state['block']['center'], state['block']['offsets'])
    preview = [Block(data['center'], data['offsets']) for data in state['preview']]
    return Board(state['bitmap'], block, preview)

  # Returns True if the block is in valid position - that is, if all of its squares
  # are in bounds and are currently unoccupied.
  def check(self, block):
    for square in block.squares():
      if (square.i < 0 or square.i >= self.rows or
          square.j < 0 or square.j >= self.cols or
          self.bitmap[square.i][square.j]):
        return False
    return True

  # Handles a list of commands to move the current block, and drops it at the end.
  # Appends a 'drop' command to the list if it does not appear, and returns the
  # new Board state object.
  #
  # If the block is ever in an invalid position during this method, throws an
  # InvalidMoveError.
  def do_commands(self, commands):
    self.block.reset_position()
    if not self.check(self.block):
      raise InvalidMoveError()
    commands.append('drop')
    for command in commands:
      if command == 'drop':
        new_board = self.place()
        return new_board
      else:
        self.block.do_command(command)
        if not self.check(self.block):
          raise InvalidMoveError()

  # Drops the current block as far as it can fall unobstructed, then locks it onto the
  # board. Returns a new board with the next block drawn from the preview list.
  #
  # Assumes the block starts out in valid position. This method mutates the current block
  #
  # If there are no blocks left in the preview list, this method will fail badly!
  # This is okay because we don't expect to look ahead that far.
  def place(self):
    while self.check(self.block):
      self.block.down()
    self.block.up()
    # Deep-copy the bitmap to avoid changing this board's state.
    new_bitmap = [list(row) for row in self.bitmap]
    for square in self.block.squares():
      new_bitmap[square.i][square.j] = 1
    new_bitmap = Board.remove_rows(new_bitmap)
    if len(self.preview) == 0:
      print "There are no blocks left in the preview list! You can't look that far ahead."
      return None
    return Board(new_bitmap, self.preview[0], self.preview[1:])

  # Returns a new board showing what would happen if the current block was placed.
  # Helpful for testing out a series of options.
  def try_place(self):
    clone = copy.copy(self)
    return clone.place()

  # Given a list of strings representing moves, 
  # Returns a board showing the result after applying those moves and placing,
  # but returns False if the set of moves is invalid.
  # Example move_list: ["left", "left", "rotate"]
  def apply_moves(self, move_list):
    valid = True
    for move in move_list:
      if (move == "left"): valid &= self.block.checked_left(self)
      elif (move == "right"): valid &= self.block.checked_right(self)
      elif (move == "up"): valid &= self.block.checked_up(self)
      elif (move == "down"): valid &= self.block.checked_down(self)
      elif (move == "rotate"): valid &= self.block.checked_rotate(self)
      elif (move == "unrotate"): valid &= self.block.checked_unrotate(self)

    if (valid == True): return self.place()
    else: return False

  # Given a list of strings representing moves, 
  # Returns a board showing what would happen after those moves and placing,
  # but returns False if the set of moves is invalid.
  # Example move_list: ["left", "left", "rotate"]
  def try_move(self, move_list):
    test_piece = copy.copy(self)
    return test_piece.apply_moves(move_list)

  # Given a list of lists of strings representing moves,
  # Returns a list of boards showing what would happen after those moves and placing.
  # Example moves: [ ["left"], ["left", "rotate"] ]
  def try_moves(self, moves):
    boards = [ ]
    for move_list in moves:
      boards.append(self.try_move(move_list))
    return boards

  # Generates a list of lists of move operations.
  # Example: [["left"], ["right"], ["right right"]]
  def gen_moves(self):
    left_num = self.block.center.j
    left_num = 12
    right_num = self.cols - left_num # self.cols = 12
    right_num = 12
    rotate_num = 4 # rotations should be 0, 1, 2, or 3

    # Begin the set of moves with placing at the current location
    moves = [ [ ] ]

    for rotate_count in range(rotate_num):
      for left in range(left_num):
        move_list = [ ]
        for i in range(left):
          move_list.append("left")
        for i in range(rotate_count):
          move_list.append("rotate")
        moves.append(move_list)
      for right in range(right_num):
        move_list = [ ]
        for i in range(right):
          move_list.append("right")
        for i in range(rotate_count):
          move_list.append("rotate")
        moves.append(move_list)

    return moves

  # A helper method used to remove any full rows from a bitmap. Returns the new bitmap.
  @staticmethod
  def remove_rows(bitmap):
    (rows, cols) = (len(bitmap), len(bitmap[0]))
    new_bitmap = [row for row in bitmap if not all(row)]
    return [cols*[0] for i in range(rows - len(new_bitmap))] + new_bitmap

# Return the best board state from the given list of boards
def best_score_board(boards_list):
    score_list = {}
    for board_index in range(len(boards_list)):    
        board = boards_list[board_index]
        if (not(board == False)):       
            this_board_score = board_score(board)
            score_list[board_index] = this_board_score
    # sort the score list (descending)
    sorted_scores = sorted(score_list.items(), key=lambda x: x[1], reverse=True)
    return sorted_scores[0][0]
    

# Score the board state given 
def board_score(board):
  rows_full = num_rows_full(board)
  holes = num_holes(board)
  height = get_height(board)
  return rows_full*1000 + holes*(-1) + height * (-10)


# Check if any row is full
def num_rows_full(board):
  (rows, cols) = (board.rows, board.cols)
  rows_full = 0
  for row in board.bitmap:
      if all(row):
          rows_full += 1
  return rows_full

# Return the number of holes in the board
def num_holes(board):
  holes = 0
  (rows, cols) = (board.rows, board.cols)
  for row in board.bitmap:
       # check if its a row of zeroes, if so, then ignore
       row_flip = [not i for i in row]
       if (not(all(row_flip))):
          for col in range(cols):
             if (not row[col]):
                 holes += 1
  return holes

def get_height(board):
  height = 0
  for row in reversed(board.bitmap):
    row_flip = [not i for i in row]
    if (not(all(row_flip))):
      height+=1
  return height

def step(board):
  move_options = board.gen_moves()
  boards = board.try_moves(move_options)
  return (move_options, boards)

if __name__ == '__main__':
  if len(sys.argv) == 3:
    # This AI executable will be called with two arguments: a JSON blob of the
    # game state and the number of seconds remaining in this game.
    seconds_left = float(sys.argv[2])

    # current board
    board = Board.construct_from_json(sys.argv[1])

    # current block
    block = board.block

    # naive AI that tests a bunch of possible move combinations
    # and returns the best one it can find.

    depth = 2
    (moves, boards) = step(board)
    last_boards = boards
    last_moves = moves
    for d in range(depth):
      new_moves = [ ]
      new_boards = [ ]
      for i in range(len(last_boards)):
        cur_moves = last_moves[i]
        cur_board = last_boards[i]
        if (cur_board != False):
          (tmp_moves, tmp_boards) = step(cur_board)
          new_boards+= tmp_boards
          for j in range(len(tmp_moves)):
            new_moves.append(cur_moves)
      last_moves = new_moves
      last_boards = new_boards

    boards = last_boards
    move_options = last_moves

    # move_options = board.gen_moves()
    #boards = board.try_moves(move_options)
    best_move_list = move_options[best_score_board(boards)]

    for move in best_move_list:
      print move
    sys.stdout.flush()

    """
    # very simple AI that moves the current block as far left as possible
    moves = []                  # list of moves to make
    while board.check(block):   # while the block in in a legal position
      block.left()              # move the block left
      moves.append('left')      # append a left command to oure moves list
    if len(moves) > 0:          # remove that last left command, as it got the block into an illegal state
      moves.pop()
    for move in moves:          # print our moves
      print move
    sys.stdout.flush()          # flush stdout
    """

    # this will do the same thing, but with different helper methods
    #while block.checked_left(board):
      #print 'left'
    #sys.stdout.flush()
